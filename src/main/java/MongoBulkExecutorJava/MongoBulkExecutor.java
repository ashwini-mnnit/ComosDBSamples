/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package MongoBulkExecutorJava;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.bson.Document;

import com.mongodb.MongoBulkWriteException;
import com.mongodb.MongoClient;
import com.mongodb.MongoClientURI;
import com.mongodb.MongoException;
import com.mongodb.bulk.BulkWriteError;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import com.mongodb.client.model.InsertManyOptions;

public class MongoBulkExecutor {

	private static String connectionString = "mongodb://indextest:MwkrkgQpwUJU0U3EDZ8jXf526CAQraJfxUYj6DW2n0SHx3p8J2ca1qUVppY0JKjBlAbJ0TA0C9ZeJRdfZKfRDw==@indextest.mongo.cosmos.azure.com:10255/?ssl=true&replicaSet=globaldb&maxIdleTimeMS=120000&appName=@indextest@&retrywrites=false";

	private static String databaseName = "bulkdb";
	private static String collectionNamePrefix = "bulkColl";
	private static int offerThroughput = 100000;
	private static String shardKey = "_id";

	private long totalWaitDurationMs;
	private long actualExecutionDurationMs;
	private long rebuildBatchDurationMs;
	private int retryCount;
	private String collectionName;

	private void refreshMetrics() {
		this.totalWaitDurationMs = 0;
		this.actualExecutionDurationMs = 0;
		this.totalWaitDurationMs = 0;
		this.retryCount = 0;
		this.collectionName = collectionNamePrefix + UUID.randomUUID().toString();

	}

	public void PrintMetrics() {
		System.out.println("######################################################################");
		System.out.println("Actual execution duration (in ms): " + this.actualExecutionDurationMs);
		System.out.println("Total wait duration (retry after) (in ms): " + this.totalWaitDurationMs);
		System.out.println("Duration to rebuild the batch (in ms) " + this.rebuildBatchDurationMs);
		System.out.println("Total retry " + this.retryCount);
		long totalDuration = this.actualExecutionDurationMs + this.totalWaitDurationMs
				+ this.rebuildBatchDurationMs; 
		System.out.println("Total Batch duration (in ms)" + totalDuration);
	}

	public MongoClient createMongoClient() {
		return new MongoClient(new MongoClientURI(connectionString));
	}

	public MongoDatabase refreshDatabaseCollection(MongoClient client) {
		MongoDatabase db = client.getDatabase(databaseName);

		db.drop();

		Document createCollectionCustomAction = new Document();
		createCollectionCustomAction.append("customAction", "CreateCollection");
		createCollectionCustomAction.append("collection", this.collectionName);
		createCollectionCustomAction.append("offerThroughput", offerThroughput);
		createCollectionCustomAction.append("shardKey", shardKey);

		Document res = db.runCommand(createCollectionCustomAction);

		return db;
	}

	public void bulkExecute(ArrayList<Document> documents, boolean orderedFlag, boolean recycleCollection)
			throws Exception {

		long documentCount = documents.size();
		this.refreshMetrics();

		MongoClient client = createMongoClient();
		MongoDatabase database = client.getDatabase(databaseName);

		if (recycleCollection) {
			database = this.refreshDatabaseCollection(client);
		}

		if (orderedFlag) {
			executeOrderedBatch(this.collectionName, database, documents);
		} else {
			executeUnOrderedBatch(this.collectionName, database, documents);
		}

		this.ValidateDocumentCount(database, documentCount);
	}

	private void ValidateDocumentCount(MongoDatabase database, long expectedCount) throws Exception {
		MongoCollection<Document> collection = database.getCollection(this.collectionName);

		long count = collection.count();

		if (count != expectedCount) {
			throw new Exception("Invalid document count , expected: " + expectedCount + " actual: " + count);
		}
	}

	private void executeOrderedBatch(String collectionName, MongoDatabase database, ArrayList<Document> documents)
			throws Exception {

		while (documents.size() > 0) {

			System.out.println("Trying to ordered insert " + documents.size() + " documents");

			long start = System.currentTimeMillis();
			try {
				database.getCollection(collectionName).insertMany(documents, new InsertManyOptions().ordered(true));
				long finish = System.currentTimeMillis();
				this.actualExecutionDurationMs += finish - start;
				documents.clear();
			} catch (MongoException exp) {
				if (exp instanceof MongoBulkWriteException) {
					if (this.isCosmosDBThrotteling((MongoBulkWriteException) exp, true)) {

						long finish = System.currentTimeMillis();
						this.actualExecutionDurationMs += finish - start;
						this.retryCount++;
						BulkWriteError bulkWriteError = ((MongoBulkWriteException) exp).getWriteErrors().get(0);
						int index = bulkWriteError.getIndex();
						int retryAfter = this.extractRetryDuration(bulkWriteError.getMessage());

						Thread.sleep(retryAfter);

						documents = this.getRemaingDocumentsFromOrderedBatch(documents, index);
						continue;
					} else {
						throw exp;
					}
				} else {
					throw exp;
				}
			}
		}
	}

	private void executeUnOrderedBatch(String collectionName, MongoDatabase database, ArrayList<Document> documents)
			throws Exception {

		while (documents.size() > 0) {

			System.out.println("Trying to unordered insert " + documents.size() + "documents");
			long start = System.currentTimeMillis();
			try {
				database.getCollection(collectionName).insertMany(documents, new InsertManyOptions().ordered(false));
				long finish = System.currentTimeMillis();
				this.actualExecutionDurationMs += finish - start;
				documents.clear();
			} catch (MongoException exp) {
				if (exp instanceof MongoBulkWriteException) {
					MongoBulkWriteException mbwe = (MongoBulkWriteException) exp;
					if (this.isCosmosDBThrotteling(mbwe, false)) {
						
						long finish = System.currentTimeMillis();
						this.actualExecutionDurationMs += finish - start;
						this.retryCount++;
						
						BulkWriteError bulkWriteError = ((MongoBulkWriteException) exp).getWriteErrors().get(0);
						int index = bulkWriteError.getIndex();
						int retryAfter = this.extractRetryDuration(bulkWriteError.getMessage());

						this.totalWaitDurationMs += retryAfter;
						Thread.sleep(retryAfter);

						documents = this.getRemaingDocumentsFromUnorderedBatch(documents, mbwe.getWriteErrors(), index);
						continue;
					}
				} else {
					throw exp;
				}
			}
		}
	}

	private ArrayList<Document> getRemaingDocumentsFromOrderedBatch(ArrayList<Document> documents, int index) {
		
		long start = System.currentTimeMillis();
		for (int i = 0; i < index; i++) {
			documents.remove(0);
		}
		long finish = System.currentTimeMillis();

		this.rebuildBatchDurationMs += finish - start;
		return documents;
	}

	private ArrayList<Document> getRemaingDocumentsFromUnorderedBatch(ArrayList<Document> documents,
			List<BulkWriteError> bulkWriteErrors, int index) {

		long start = System.currentTimeMillis();
		ArrayList<Document> rv = new ArrayList<Document>();

		for (BulkWriteError bulkWriteError : bulkWriteErrors) {
			if (bulkWriteError.getCode() == 16500) {
				rv.add(documents.get(bulkWriteError.getIndex()));
			}
		}
		long finish = System.currentTimeMillis();

		this.rebuildBatchDurationMs += finish - start;

		return rv;
	}

	private boolean isCosmosDBThrotteling(MongoBulkWriteException bulkWriteException, boolean ordered)
			throws Exception {
		if (ordered) {
			// ordered
			// contains only one error and that is throttling.
			if ((bulkWriteException.getWriteErrors().size() == 1)
					&& bulkWriteException.getWriteErrors().get(0).getCode() == 16500) {
				return true;
			}
		} else {
			// unordered
			// Check for one of that
			if ((bulkWriteException.getWriteErrors().size() > 0)
					&& bulkWriteException.getWriteErrors().get(0).getCode() == 16500) {
				return true;
			}
		}

		return false;
	}

	private int extractRetryDuration(String message) throws Exception {
		Pattern pattern = Pattern.compile("RetryAfterMs=([0-9]+)");
		Matcher matcher = pattern.matcher(message);

		int retryAfter = 0;

		if (matcher.find()) {
			retryAfter = Integer.parseInt(matcher.group(1));
		}

		if (retryAfter <= 0) {
			throw new Exception("Invalid retryAfterMs from the cosmos db error message: " + message);
		}

		return retryAfter;
	}
}
